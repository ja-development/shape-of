let shapeOf;!function(){shapeOf=function(e){return r(this,e)};let e=e=>{if(!Array.isArray(e))return e;{let a=[];for(let t=0;t<e.length;t++){let r=e[t];if(Array.isArray(r))for(let l=0;l<r.length;l++)a.push(r[l]);else a.push(r)}return a}},a=Number.isInteger||(e=>"number"==typeof e&&e==e&&e!==1/0&&e!==-1/0&&Math.floor(e)===e),t=(e,a)=>{if(e=e.split("."),a=a.split("."),3!==e.length||3!==a.length)throw"Bad version format";return e[0]=parseInt(e[0]),e[1]=parseInt(e[1]),e[2]=parseInt(e[2]),a[0]=parseInt(a[0]),a[1]=parseInt(a[1]),a[2]=parseInt(a[2]),e[0]>=a[0]&&(e[1]>=a[1]||e[0]>a[0])&&(e[2]>=a[2]||e[1]>a[1])},r=(e,a,t)=>{let r={};(t=t||{}).baseObject&&(r=t.baseObject,delete t.baseObject),delete t.exclude,l(t);let i=t.exclude;return -1===i.indexOf("shouldBe")&&(r.shouldBe=u.bind(e,{obj:a,...t})),r.is=r.shouldBe,-1===i.indexOf("shouldBeExactly")&&(r.shouldBeExactly=r.isExactly=u.bind(e,{obj:a,exact:!0,...t})),-1===i.indexOf("returnsObject")&&(r.returnsObject=s(e,{obj:a,...t})),-1===i.indexOf("returnsResults")&&(r.returnsResults=o(e,{obj:a,...t})),-1===i.indexOf("shouldNotBe")&&(r.shouldNotBe=r.isNot=((e,a)=>!u(e,a)).bind(e,{obj:a,...t})),-1===i.indexOf("throwsOnInvalid")&&(r.throwsOnInvalid=n(e,a,t)),-1===i.indexOf("onInvalid")&&(r.onInvalid=f.bind(e,e,{obj:a,...t})),-1===i.indexOf("onValid")&&(r.onValid=h.bind(e,e,{obj:a,...t})),-1===i.indexOf("onComplete")&&(r.onComplete=p.bind(e,e,{obj:a,...t})),r},l=(e,...a)=>{e.exclude=e.exclude||[],(e.returnsObject||e.returnsResults)&&(a=(a=a.concat(["returnsObject"])).concat(["returnsResults"])),e.throwsOnInvalid&&(a=a.concat(["throwsOnInvalid"])),a.forEach(a=>{-1===e.exclude.indexOf(a)&&e.exclude.push(a)})},n=(e,a,t)=>{let l={obj:a,throwsOnInvalid:!0,...t};return l.baseObject=i.bind(e,e,l),r(e,a,l)},i=(e,a,t)=>(t&&(a.errorObj=t),n(e,a.obj,a)),s=(e,a)=>{let t={obj:a.obj,returnsObject:!0,...a};return r(e,a.obj,t)},o=(e,a)=>{let t={obj:a.obj,returnsResults:!0,...a};return r(e,a.obj,t)},f=(e,a,t)=>{let l=a.onInvalid||[];return l.push(t),r(e,a.obj,{onInvalid:l,...a})},h=(e,a,t)=>{let l=a.onValid||[];return l.push(t),r(e,a.obj,{onValid:l,...a})},p=(e,a,t)=>{let l=a.onComplete||[];return l.push(t),r(e,a.obj,{onComplete:l,...a})},u=(e,a)=>{let t=e.obj,r=e.returnsObject||!1,l=e.returnsResults||!1,n,i=!1,s=e.log||[];if(e={log:s,...e},shapeOf._shouldBeOptionsChain||(shapeOf._shouldBeOptionsChain=[]),shapeOf._lastShouldBeOptions=e,shapeOf._shouldBeOptionsChain.push(e),shapeOf.isValidator(a))void 0===(n=y(a,t))?O(e,`Failed: Validator '${a._name}'`,t):t!==n&&O(e,`Mutation: Validator '${a._name}'`,t,n);else if("function"==typeof a)void 0===(n=a(t))?O(e,`Failed: Validation using functional validator '${a.name}'`,t):t!==n&&O(e,`Mutation: Functional validator '${a.name}'`,t,n);else if(Array.isArray(a)){let o=a.length===t.length;for(let f=0;f<t.length&&o;f++){let h=u({...e,obj:t[f],returnsObject:!0},a[f]);(o=o&&void 0!==h)||O(e,`Failed: Array element at index ${f}`,t[f]),h!==t[f]&&o&&(O(e,`Mutation: Array element at index ${f}`,t[f],h),t[f]=h)}o?n=t:O(e,"Failed: Array",t)}else"object"==typeof a?void 0===(n=c(t,a,e))&&O(e,"Failed: Object",t):a===t?n=t:O(e,"Failed: Strict equality",t,n);if(i=void 0!==n,e.onInvalid&&!i&&e.onInvalid.forEach(e=>e(t,a)),e.onValid&&i&&e.onValid.forEach(e=>e(t,a)),e.throwsOnInvalid&&!i){if(e.errorObj)throw e.errorObj;throw"Invalid shape detected"}return(e.onComplete&&e.onComplete.forEach(e=>e(t,a)),shapeOf._lastShouldBeOptions=shapeOf._shouldBeOptionsChain.pop(),r)?n:l?{success:i,log:s,obj:t}:i},c=(e,a,t)=>{if("object"!=typeof e||null===e)return;let r=t.returnsObject||!1,l=t.exact||!1;t={...t,returnsObject:!0};let n=Object.keys(a);for(let i=n.length-1;i>=0;i--){let s=n[i],o=a[s];if(void 0===e[s]){if(o._optional)continue;O(t,`Failed: Object with missing key '${s}'`);return}let f=e[s],h=u({...t,obj:f},o);if(void 0===h){O(t,`Failed: Object at key '${s}'`,f);return}h!==e[s]&&(O(t,`Mutation: Object field '${s}'`,e[s],h),e[s]=h)}if(l){let p=Object.keys(e);for(let c=p.length-1;c>=0;c--)if(-1===n.indexOf(p[c])){O(t,`Failed: Object with extraneous key '${p[c]}'`);return}}return!r||e},O=(e,a,...t)=>{if(e?"string"==typeof e&&(void 0!==a&&t.push(a),a=e,e=shapeOf._lastShouldBeOptions):e=shapeOf._lastShouldBeOptions,!e.returnsResults)return;let r=e.log,l={message:a};t.length>0&&(1===t.length&&(t=t[0]),l.obj=t),r.push(l)},d=function(...e){if(e.length<this._requiredArgsCount)throw`Validator '${this._name}' requires at least ${this._requiredArgsCount} arguments`;let a={...this};a._callChain=[].concat(this._callChain),a._callChain.pop(),a._thisCall=b(this._thisCall),a._thisCall.args=[].concat(e),a._callChain.push(a._thisCall);let t=Object.keys(a._subValidators);for(let r=t.length-1;r>=0;r--){let l=t[r],n=a._subValidators[l],i=m(n._name,n._callback,{...n._options,_callChain:a._callChain}),s=d.bind(i),o=Object.keys(i);for(let f=o.length-1;f>=0;f--){let h=o[f];s[h]=a[h]}a[l]=s}let p=d.bind(a),u=Object.keys(a);for(let c=u.length-1;c>=0;c--){let O=u[c];p[O]=a[O]}return p};shapeOf.Validator=function(e,a,t){t=t||{};let r=m(e,a,t),l=d.bind(r);return l=Object.assign(l,r),t.parent&&$(t.parent,l),r._aliases.forEach(e=>{shapeOf.Validator._validators[e]=l}),shapeOf.Validator._validators[r._name]=l,l},shapeOf.Validator._validators={};let g={validator:"token"};shapeOf.isValidator=e=>Boolean(e&&e._validatorToken&&e._validatorToken===g&&e._callback&&"function"==typeof e._callback&&e._callChain&&e._thisCall);let b=(e,a,t)=>"object"==typeof e?{name:e.name,args:[].concat(e.args),_callback:e._callback}:{name:e,args:a,_callback:t},m=(e,a,t,r)=>{t=t||{};let l={},n=[].concat((t={...r=r||{},...t})._callChain||[]),i=b(e,[],a);return n.push(i),l._name=e,l._thisCall=i,l._callChain=n,l._options=t,l._optional=t.optional||!1,l._requiredArgsCount=t.requiredArgsCount||Math.max(0,a.length-1),l._callback=a,l._aliases=t.aliases||[],l._subValidators={},l._validatorToken=g,t.serialize&&(l._serialize=t.serialize),t.deserialize&&(l._deserialize=t.deserialize),"string"==typeof l._aliases&&(l._aliases=[l._aliases]),l},$=(e,a)=>{if("string"==typeof e&&!(e=shapeOf.Validator._validators[e]))throw"Unknown validator: "+e;[a._name].concat(a._aliases).forEach(t=>{let r=t;r=(r=(r=r.replace(e._name,"")).split("."))[r.length-1];let l={},n=Object.keys(a);for(let i=n.length-1;i>=0;i--){let s=n[i];l[s]=a[s]}e._optional&&(l._optional=!0);let o=[].concat(e._callChain).concat(a._callChain);l._callChain=o;let f=d.bind(l);f=Object.assign(f,l),e[r]=f,e._subValidators[r]=f})},y=(e,a)=>{let t=e._callChain;for(let r=0;r<t.length;r++){let l=t[r];if(l.args.length<l._requiredArgsCount)throw"Missing required arguments for validator: "+l._name;let n=l.args.concat([a]);if(void 0===(a=l._callback(...n)))break}return a};shapeOf.serialize=(e,a)=>{let t={_shapeOfVersion:shapeOf.version,_shapeOfSchemaVersion:shapeOf.compatibleSchemaVersion,schema:k(e)};return(a=a||{}).returnsObject?t:JSON.stringify(t)},shapeOf.deserialize=e=>{if("string"==typeof e)try{e=JSON.parse(e)}catch(a){throw"Error while deserializing schema:\n"+a.toString()}if(!e._shapeOfVersion||!e._shapeOfSchemaVersion||!e.schema)throw"Object doesn't appear to be a valid shapeOf schema.";if(!t(shapeOf.compatibleSchemaVersion,e._shapeOfSchemaVersion))throw`Incompatible schema versions, current version == ${shapeOf.compatibleSchemaVersion}, schema version == ${e._shapeOfSchemaVersion}`;return v(e.schema)};let _=e=>{if(!e.type||"validator"!==e.type)throw"Object isn't a validator type: "+e.toString();if(!e.callChain||!Array.isArray(e.callChain)||!e.name||"string"!=typeof e.name)throw"Malformed validator: "+e.toString();let a=!1;e.optional&&"boolean"==typeof e.optional&&(a=!0);let t;return e.callChain.forEach(a=>{if(!a.name||"string"!=typeof a.name||!a.args||!Array.isArray(a.args))throw"Malformed validator: "+e.toString();let r=shapeOf.Validator._validators[a.name];if(void 0===r)throw"Validator not found: "+a.name;let l=a.name.split(".").pop();if(t&&!t[l])throw"Cannot find sub-validator "+a.name;if(a.args.length>0){let n=[];a.args.forEach(e=>n.push(v(e))),t=t?t[l](...n):r(...n)}else t=t?t[l]:r}),t},v=(e,a)=>{if(!e.type||"string"!=typeof e.type)throw"Object isn't a valid type: "+e.toString();if(void 0===e.value&&"validator"!==e.type)throw"Object missing value: "+e.toString();let t;if("object"===e.type){if(!Array.isArray(e.value))throw"Type 'object' value must be an array";t={},e.value.forEach(e=>{v(e,t)})}else if("field"===e.type){if(!e.name||"string"!=typeof e.name)throw"Illegal/missing field name for object "+a.toString();if(!a)throw"No parent present for 'field' type";a[e.name]=v(e.value)}else if("array"===e.type){if(!Array.isArray(e.value))throw"Type 'array' value must be array";t=[],e.value.forEach(e=>{t.push(v(e))})}else if("primitive"===e.type)t=e.value;else if("validator"===e.type)t=_(e);else if("regexp"===e.type){if("string"!=typeof e.value||"string"!=typeof e.flags)throw"RegExp object missing required field";t=RegExp(e.value,e.flags)}else throw"Unknown object type: "+e.type;return t},j=e=>{let a={type:"validator",name:e._name};e._optional&&(a.optional=!0);let t=a.callChain=[],r=e._callChain;if(r&&r.length>0)for(let l=0;l<r.length;l++){let n=r[l],i=n.args,s=[],o={name:n.name,args:s};for(let f=0;f<i.length;f++)s.push(k(i[f]));t.push(o)}return e._serialize&&(a={...a,...e._serialize()}),a},k=e=>{let a={type:"primitive"};if(e.toJSON)a=e;else if(shapeOf.isValidator(e))a=j(e);else if(e.serialize&&"function"==typeof e.serialize)a={...a,...e.serialize()};else if(Array.isArray(e)){a.type="array";let t=a.value=[];for(let r=0;r<e.length;r++)t.push(k(e[r]))}else if(e instanceof RegExp){let l=e.toString().split("/"),n=l.pop();l.shift(),l=l.join("/"),a.type="regexp",a.value=l,a.flags=n}else if("object"==typeof e&&null!==e){a.type="object";let i=Object.keys(e),s=a.value=[];for(let o=0;o<i.length;o++){let f=i[o];s.push({type:"field",name:f,value:k(e[f])})}}else a.value=e;return a},C=e=>{if("number"==typeof e)return e},w=(e,a,t)=>{if(t<=Math.max(e,a)&&t>=Math.min(e,a))return t},V=(e,a)=>{if(a>=e)return a},x=(e,a)=>{if(a<=e)return a},A=e=>{if(a(e))return e},q=e=>{if("string"==typeof e)return e},E=(...e)=>{let a="",t="",r;if(e.length<2||e.length>3)throw"String pattern validator requires between one and two arguments";if(t=e[0],2===e.length?r=e[1]:(a=e[1],r=e[2]),"string"==typeof t)t=RegExp(t,a);else if(t instanceof RegExp)3===e.length&&(t=RegExp(t,a));else throw"shapeOf.string.pattern() only accepts strings and RegExp objects as an argument";if(t.test(r))return r},S=e=>{if(z.test(e))return e},z=/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])\.){3}(25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])\])|(([a-zA-Z0-9][a-zA-Z\-0-9]+\.)+(?![wW][eE][bB])[a-zA-Z]{2,}))$/,B=e=>{if(I.test(e))return e},I=/^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\.(?!$)|$)){4}$/,F=e=>{if(T.test(e))return e},T="^\\s*(({{O0}}{7}([0-9A-Fa-f]{1,4}|:))|({{O0}}{6}(:[0-9A-Fa-f]{1,4}|({{O2}}(\\.{{O2}}){3})|:))|({{O0}}{5}(({{O1}}{1,2})|:({{O2}}(\\.{{O2}}){3})|:))|({{O0}}{4}(({{O1}}{1,3})|({{O1}}?:({{O2}}(\\.{{O2}}){3}))|:))|({{O0}}{3}(({{O1}}{1,4})|({{O1}}{0,2}:({{O2}}(\\.{{O2}}){3}))|:))|({{O0}}{2}(({{O1}}{1,5})|({{O1}}{0,3}:({{O2}}(\\.{{O2}}){3}))|:))|({{O0}}{1}(({{O1}}{1,6})|({{O1}}{0,4}:({{O2}}(\\.{{O2}}){3}))|:))|(:(({{O1}}{1,7})|({{O1}}{0,5}:({{O2}}(\\.{{O2}}){3}))|:)))(%.+)?\\s*$";T=RegExp(T=(T=(T=T.replace(/\{\{O0\}\}/g,"([0-9A-Fa-f]{1,4}:)")).replace(/\{\{O1\}\}/g,"(:[0-9A-Fa-f]{1,4})")).replace(/\{\{O2\}\}/g,"(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)"));let R=(...e)=>{if(e.length<2||e.length>3)throw"Length validator requires between one and two arguments";let a=e[e.length-1];if(2===e.length){if(a.length===e[0])return a}else{let t=Math.min(e[0],e[1]),r=Math.max(e[0],e[1]);if(a.length>=t&&a.length<=r)return a}},M=e=>{if(Array.isArray(e))return e},N=e=>{if("boolean"==typeof e)return e},P=e=>{if("object"==typeof e&&null!==e)return e},Z=e=>{if(null===e)return e},U=e=>q(e)||N(e)||C(e)||Z(e),H=(...a)=>{if(a.length<2)throw"arrayOf validator requires at least one argument";let t=a.pop(),r=e(a),l;if(Array.isArray(t)){for(let n=t.length-1;n>=0;n--){l=!1;for(let i=r.length-1;i>=0;i--){let s=shapeOf(t[n]).returnsObject.shouldBe(r[i]);if(l=l||void 0!==s){s!==t[n]&&(t[n]=s);break}}if(!l)break}if(l)return t}},J=(...a)=>{if(a.length<2)throw"objectOf validator requires at least one argument";let t=a.pop(),r=e(a),l;if("object"!=typeof t||null===t)return;let n=Object.keys(t);for(let i=n.length-1;i>=0;i--){let s=t[n[i]];l=!1;for(let o=r.length-1;o>=0;o--){let f=shapeOf(s).returnsObject.shouldBe(r[o]);if(l=l||void 0!==f){f!==s&&(t[n[i]]=f);break}}if(!l)break}if(l)return t},L=(...a)=>{if(a.length<2)throw"oneOf validator requires at least one argument";let t=a.pop(),r=e(a);for(let l=r.length-1;l>=0;l--)if(r[l]===t)return t},W=(...a)=>{if(a.length<2)throw"oneOfType validator requires at least one argument";let t=a.pop(),r=e(a);for(let l=0;l<r.length;l++)if(shapeOf(t).shouldBeExactly(r[l]))return t},D=(...a)=>{if(a.length<2)throw"eachOfType validator requires at least one argument";let t=a.pop(),r=e(a);for(let l=0;l<r.length;l++)if(!shapeOf(t).shouldBeExactly(r[l])){shapeOf.isValidator(r[l])?O(`Failed: Validator 'shapeOf.eachOf' -> '${r[l]._name}'`,t):O(`Failed: Validator 'shapeOf.eachOf' -> index ${l}`,t);return}return O('Passed: Validator "shapeOf.eachOf"',t),t};shapeOf.optional={},[{name:"shapeOf.number",callback:C},{name:"shapeOf.number.range",callback:w,options:{parent:"shapeOf.number",requiredArgsCount:2}},{name:"shapeOf.number.min",callback:V,options:{parent:"shapeOf.number",aliases:"shapeOf.number.greaterThanOrEqualTo",requiredArgsCount:1}},{name:"shapeOf.number.max",callback:x,options:{parent:"shapeOf.number",aliases:"shapeOf.number.lessThanOrEqualTo",requiredArgsCount:1}},{name:"shapeOf.integer",callback:A},{name:"shapeOf.integer.range",callback:w,options:{parent:"shapeOf.integer",requiredArgsCount:2}},{name:"shapeOf.integer.min",callback:V,options:{parent:"shapeOf.integer",aliases:"shapeOf.integer.greaterThanOrEqualTo",requiredArgsCount:1}},{name:"shapeOf.integer.max",callback:x,options:{parent:"shapeOf.integer",aliases:"shapeOf.integer.lessThanOrEqualTo",requiredArgsCount:1}},{name:"shapeOf.string",callback:q},{name:"shapeOf.string.size",callback:R,options:{parent:"shapeOf.string",aliases:"shapeOf.string.ofSize",requiredArgsCount:1}},{name:"shapeOf.string.pattern",callback:E,options:{parent:"shapeOf.string",aliases:"shapeOf.string.matching",requiredArgsCount:1}},{name:"shapeOf.string.email",callback:S,options:{parent:"shapeOf.string",aliases:"shapeOf.string.ofEmail"}},{name:"shapeOf.string.IPv4",callback:B,options:{parent:"shapeOf.string",aliases:["shapeOf.string.ofIPv4","shapeOf.string.ipv4",]}},{name:"shapeOf.string.IPv6",callback:F,options:{parent:"shapeOf.string",aliases:["shapeOf.string.ofIPv6","shapeOf.string.ipv6",]}},{name:"shapeOf.array",callback:M},{name:"shapeOf.array.size",callback:R,options:{parent:"shapeOf.array",aliases:"shapeOf.array.ofSize",requiredArgsCount:1}},{name:"shapeOf.bool",callback:N,options:{aliases:"shapeOf.boolean"}},{name:"shapeOf.object",callback:P},{name:"shapeOf.null",callback:Z},{name:"shapeOf.primitive",callback:U},{name:"shapeOf.arrayOf",callback:H},{name:"shapeOf.arrayOf.size",callback:R,options:{parent:"shapeOf.arrayOf",aliases:"shapeOf.arrayOf.ofSize",requiredArgsCount:1}},{name:"shapeOf.objectOf",callback:J},{name:"shapeOf.oneOf",callback:L,options:{requiredArgsCount:1}},{name:"shapeOf.oneOfType",callback:W,options:{requiredArgsCount:1}},{name:"shapeOf.eachOf",callback:D,options:{aliases:"shapeOf.each",requiredArgsCount:1}},].forEach(e=>{let a=shapeOf.Validator(e.name,e.callback,e.options),t=e.options||{},r=e.name.split("."),l=(t.parent||"").split("."),n={...e.options,optional:!0},i=r[0]+".optional."+r.filter((e,a)=>a>0).join(".");if(n.parent){let s=l[0]+".optional."+l.filter((e,a)=>a>0).join(".");n.parent=s}let o=shapeOf.Validator(i,e.callback,n);"shapeOf"===r[0]&&2===r.length&&(shapeOf[r[1]]=a,shapeOf.optional[r[1]]=o);let f=t.aliases||"";"string"==typeof f&&(f=[f]),f.forEach(e=>{let t=e.split(".");"shapeOf"===t[0]&&2===t.length&&(shapeOf[t[1]]=a,shapeOf.optional[t[1]]=o)})})}(),shapeOf._versionCompatibilityHistory={"0.0.7":"0.0.7","0.0.6":"0.0.6","0.0.8":"0.0.8","0.0.9":"0.0.8","0.0.5":"0.0.5"},shapeOf.version="0.0.9",shapeOf.compatibleSchemaVersion="0.0.8",module.exports=shapeOf;